= Introducción a Perl 6
:description: Una introducción general a Perl 6
:Author: Naoum Hankache
:keywords: perl6, perl 6, introducción, perl6intro, introducción a perl 6, tutorial de perl 6, perl 6 intro
:Email: naoum@hankache.com
:Revision: 1.0
:icons: font
:source-highlighter: pygments
//:pygments-style: manni
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:doctype: book

Este documento es una guía rápida del lenguaje de programación Perl 6.
Para los novatos en Perl 6 sería un punto de partida y puesta en marcha.

Algunas partes de este documento hacen referencia a otras partes (más completas y precisas) de la documentación de Perl 6.
Consulta la documentación de Perl 6 si necesitas más información sobre algo concreto.

A lo largo de este documento encontrarás ejemplos de los temas más comentados.
Es conveniente que pruebes todos los ejemplos para entenderlos bien.

.Licencia
Este trabajo está bajo la licencia Creative Commons Attribution-ShareAlike 4.0 International License. Puedes encontrar una copia de esta licencia en

* http://creativecommons.org/licenses/by-sa/4.0/

.Colaboración
Puedes colaborar en este documento en:

* http://github.com/hankache/perl6intro

.Sugerencias y comentarios
Todas las sugerencias y comentarios son bienvenidos:
naoum@hankache.com

:sectnums:
== Introducción
=== Qué es Perl 6
Perl 6 es un lenguaje de alto nivel, de propósito general y de tipado gradual.
Perl 6 es multiparadigma y soporta programación Procedural, Orientada a Objetos y Funcional.

.El lema de Perl 6:
* TMTOWTDI (Pronunciado como Tim Toady): There is more than one way to do it (Hay más de una forma para hacer algo).
* Las cosas fáciles deben permanecer fáciles, las cosas difíciles deberían ser fáciles y las cosas imposibles deberían ser difíciles.

=== Jerga
* *Perl 6*: Es una especificación con un banco de pruebas.
Las implementaciones que pasan el banco de pruebas de la especificación se consideran Perl 6.
* *Rakudo*: Es un compilador para Perl 6.
* *Rakudobrew*: Es un script de Perl5 para instalar Rakudo desde su código fuente.
* *Panda*: Es una herramienta para instalar módulos de Perl 6.
* *Rakudo Star*: Es un paquete que incluye Rakudo, Panda, una colección de módulos de Perl 6 y documentación.

=== Instalación de Perl 6
.Linux
. Instalación de Rakudobrew: https://github.com/tadzik/rakudobrew

. Instalación de Rakudo: En el terminal, introduce el siguiente comando `rakudobrew build moar`

. Instalación de Panda: En el terminal, introduce el siguiente comando `rakudobrew build-panda`

.OSX
Sigue los mismos pasos de la instalación para Linux +
O +
Realiza la instalación con homebrew: `brew install rakudo-star`

.Windows
. Descarga el instalador más reciente (.MSI) desde http://rakudo.org/downloads/star/ +
Descarga la versión de 32-bit o 64-bit dependiendo de tu arquitectura.
. Finalizada la instalación, agrega C:\rakudo\bin al PATH del sistema.

.Docker
. Consigue la imagen oficial de Docker `docker pull rakudo-star`
. Y ejecuta un contenedor con la imagen `docker run -it rakudo-star`

=== Ejecutando código en Perl 6

Puedes ejecutar código Perl 6 mediante REPL (Read-Eval-Print Loop). Para ello, abre un terminal, introduce `perl6` y pulsa [Enter]. Aparecerá el prompt `>`. Ahora introduce una línea de código, pulsa [Enter] y aparecerá una línea nueva con el resultado. Puedes introducir otra línea o `exit` y pulsar [Enter] para salir al sistema.

También puedes escribir tu código de Perl 6 en un archivo de texto, guardarlo y ejecutarlo. Es recomendable que el nombre de este archivo de texto tenga la extensión `.pl6`. Ejecuta el archivo de esta forma: `perl6 nombre-archivo.pl6` desde un terminal y pulsa [Enter]. La ejecución suele mostrar el resultado de sentencias como `say` para visualizar por la salida estándar contenidos de texto con un salto de línea al final .

REPL normalmente se utiliza para probar trozos pequeños de código, como una línea. En el caso de programas con más de una línea de código es recomendable guardarlos en un archivo y ejecutarlos como hemos visto.

También puedes ejecutar una línea de código de forma "in-line" mediante el parámetro -e de la siguiente forma: `perl6 -e 'línea de código Perl 6'` y pulsando [Enter].

[TIP]
--
Rakudo Star incorpora un editor de líneas con más funcionalidades para REPL.

Si instalaste Rakudo en lugar de Rakudo Star es probable que no tengas estas funcionalidades (historial con flechas verticales, edición de la línea con flechas horizontales, autocompletar con TAB, etc.). Para instalar estas funcionalidades utiliza estos comandos:

* `panda install Linenoise` debe funcionar en Windows, Linux y OSX

* `panda install Readline` si tienes Linux y prefieres la librería _Readline_
--

=== Editores
Como casi siempre vamos a guardar nuestros programas de Perl 6 en archivos, necesitamos un editor de textos decente que reconozca la sintaxis de Perl 6.

Yo recomiendo y utilizo https://atom.io/[Atom]. Es un editor de textos moderno que reconoce y visualiza bien la sintaxis de Perl 6.
https://atom.io/packages/language-perl6fe[Perl6-fe] es un paquete de Atom con una visualización alternativa de la sintaxis de Perl 6. Deriva del paquete original, tiene muchas correcciones y más funcionalidades.

En la comunidad también se utiliza http://www.vim.org/[Vim], https://www.gnu.org/software/emacs/[Emacs] o http://padre.perlide.org/[Padre].

Las últimas versiones de Vim incorporan la visualización de la sintaxis de Perl 6, mientras que Emacs y Padre necesitan instalar paquetes adicionales.


=== ¡Hola Mundo!
Comenzamos con El ritual `hola mundo`.

[source,perl6]
say 'hola mundo';

que también puede escribirse como:

[source,perl6]
'hola mundo'.say;

=== Sintaxis general
Perl 6 tiene *forma libre*, esto es, eres libre (casi siempre) de utilizar cualquier cantidad de espacios en blanco.

*Una Sentencia* normalmente es una línea lógica de código que finaliza en punto y coma:
`say "Hola" if True;`

*Las Expresiones* son sentencias especiales que devuelven un valor:
`1+2` devuelve `3`

Las expresiones están formadas por *Términos* y *Operadores*.

*Los Términos* pueden ser:

* *Variables*: Un valor que puede manipularse y ser cambiado.

* *Literales*: Un valor constante como un número o un texto.

*Los Operadores* se clasifican en estos tipos:

|===

| *Tipo* | *Significado* | *Ejemplo*

| Prefijo | Antes del término | `++1`

| Infijo | Entre términos | `1+2`

| Sufijo | Después del término | `1++`

| Circumfijo | Al principio y al final del término | `(1)`

| Precircumfijo | Después del término, al principio y al final de otro | `Array[1]`

|===

==== Identificadores
Los identificadores son los nombres que se le dan a los términos cuando los defines.

.Reglas:
* Deben comenzar con un carácter alfabético o un guión bajo.

* Pueden contener dígitos excepto en el primer carácter.

* Pueden contener guión medio o apóstrofe seguido de un carácter alfabético, no al final.

|===

| *Válido* | *No válido*

| `var1` | `1var`

| `var-uno` | `var-1`

| `var'uno` | `var'1`

| `var1_` | `var1'`

| `_var` | `-var`

|===

.Convención de nombres:
* Notación Camello: `variableNum1`

* Notación Kebab: `variable-num1`

* Notación Serpiente: `variable_num1`

Puedes nombrar tus identificadores como quieras, pero es recomendable utilizar una convención consistente.

Utiliza nombres significativos para hacerlo más fácil, a tí y a los demás.

* `var1 = var2 * var3` es correcto pero no tiene un propósito evidente.
* `mes-salario = dia-frecuencia * dias-trabajo` es una buena forma de nombrar las variables.

==== Comentarios
Un comentario es un texto, sirve como anotación y el compilador no lo tiene en cuenta.

Hay 3 tipos de comentarios:

* De una línea:
+
[source,perl6]
# Esto es un comentario de una línea

* Incrustado:
+
[source,perl6]
say #`(Esto es un comentario incrustado) "Hola Mundo."

* De varias líneas:
+
[source,perl6]
-----------------------------
=begin comentario
Esto es un comentario de varias líneas.
Comentario 1
Comentario 2
=end comentario
-----------------------------

==== Comillas
El texto tiene que ir entre comillas dobles o simples.

Utiliza siempre doble comillas:

* si el texto contiene un apóstrofe.

* si el texto necesita visualizar el texto de una variable (interpolación de variable).

[source,perl6]
-----------------------------------
say 'Hola Mundo';   # Hola Mundo
say "Hola Mundo";   # Hola Mundo
say "Ven pa'ca cordera";    # Ven pa'ca cordera
my $nombre = 'Juan De Dios';
say 'Hola $nombre';   # Hola $nombre
say "Hola $nombre";   # Hola Juan De Dios
-----------------------------------

== Operadores
La siguiente tabla muestra los operadores más utilizados.
[cols="^.^5m,^.^5m,.^20,.^20m,.^20m", options="header"]
|===

| Operador | Tipo | Descripción | Ejemplo | Resultado

| + | Infijo | Suma | 1 + 2 | 3

| - | Infijo | Resta | 3 - 1 | 2

| * | Infijo | Multiplicación | 3 * 2 | 6

| ** | Infijo | Potencia | 3 ** 2 | 9

| / | Infijo | División | 3 / 2 | 1.5

| div | Infijo | División Entera (redondeo inferior) | 3 div 2 | 1

| % | Infijo | Resto | 7 % 4 | 3

.2+| %% .2+| Infijo .2+| Divisible | 6 %% 4 | Falso

<| 6 %% 3 <| Verdadero

| gcd | Infijo | Máximo común denominador | 6 gcd 9 | 3

| lcm | Infijo | Mínimo común múltiplo | 6 lcm 9 | 18

| == | Infijo | Igual | 9 == 7  | Falso

| != | Infijo | No igual | 9 != 7  | Verdadero

| < | Infijo | Menor que | 9 < 7  | Falso

| > | Infijo | Mayor que | 9 > 7  | Verdadero

| \<= | Infijo | Menor o igual | 7 \<= 7  | Verdadero

| >= | Infijo | Mayor o igual | 9 >= 7  | Verdadero

| eq | Infijo | Texto igual | "Juan" eq "Juan"  | Verdadero

| ne | Infijo | Texto no igual | "Juan" ne "Juana"  | Verdadero

| = | Infijo | Asignación | my $var = 7  | Asigna el valor `7` a la variable `$var`

.2+| ~ .2+| Infijo .2+| Texto concatenado | 9 ~ 7 | 97

<m| "Buenos " ~ "días"  <| Buenos días

.2+| x .2+| Infijo .2+| Texto replicado | 13 x 3  | 131313

<| "Hola " x 3  <| Hola Hola Hola

| ~~ | Infijo | Expresión regular |   |

.2+| ++ | Prefijo | Incremento | my $var = 2; ++$var;  | Incrementa la variable por 1 y devuelve `3` como resultado

<m| Sufijo <d| Incremento <m| my $var = 2; $var++;  <| Devuelve la variable `2` y después la incrementa

.2+|\--| Prefijo | Decremento | my $var = 2; --$var;  | Decrementa la variable en 1 y devuelve `1` como resultado

<m| Sufijo <d| Decremento <m| my $var = 2; $var--;  <| Devuelve la variable `2` y después la decrementa

.3+| + .3+| Prefijo .3+| Fuerza el operando a un valor numérico | +"3"  | 3

<| +Verdadero <| 1

<| +Falso <| 0

.3+| - .3+| Prefijo .3+| Fuerza el operando a un valor numérico y devuelve la negación | -"3"  | -3

<| -Verdadero <| -1

<| -Falso <| 0

.6+| ? .6+| Prefijo .6+| Fuerza el operando a un valor booleano | ?0 | Falso

<| ?9.8 <| Verdadero

<| ?"Hola" <| Verdadero

<| ?"" <| Falso

<| my $var; ?$var; <| Falso

<| my $var = 7; ?$var; <| Verdadero

| ! | Prefijo | Fuerza el operador a un valor booleano y devuelve la negación | !4 | Falso

| .. | Infijo | Constructor de Series |  0..5  | Crea una serie de 0 a 5

| ..^ | Infijo | Constructor de Series |  0..^5  | Crea una serie de 0 a 4

| ^.. | Infijo | Constructor de Series |  0^..5  | Crea una serie de 1 a 5

| \^..^ | Infijo | Constructor de Series |  0\^..^5  | Crea una serie de 1 a 4

| ^ | Prefijo | Constructor de Series |  ^5  | Igual que 0..^5 Crea una serie de 0 a 4

| ... | Infijo | Constructor de listas vago |  0...9999  |  devuelve los elementos si son solicitados

.2+| {vbar} .2+| Prefijo .2+| Aplanamiento | {vbar}(0..5)  | (0 1 2 3 4 5)

<| {vbar}(0\^..^5)  <| (1 2 3 4)

|===

NOTA: En http://doc.perl6.org/language/operators tienes una lista completa de los operadores, incluyendo su precedencia.

== Variables
Las variables en Perl 6 se reparten en tres categorías: Escalares, Arrays y Hashes.

Un *sigil* (Signo en Latín) es un carácter utilizado como prefijo para categorizar variables.

* `$` para escalares
* `@` para arrays
* `%` para hashes

=== Escalares
Un escalar contiene un valor o referencia.

[source,perl6]
----
#Texto
my $nombre = 'Juan De Dios';
say $nombre;

#Entero
my $edad = 99;
say $edad;
----

Dependiendo del valor contenido, un escalar puede realizar una serie de operaciones concretas.

[source,perl6]
.Texto
----
my $nombre = 'Juan De Dios';
say $nombre.uc;
say $nombre.chars;
say $nombre.flip;
----

----
JUAN DE DIOS
12
soiD eD nauJ
----

NOTA: Consulta http://doc.perl6.org/type/Str para una lista completa de métodos de texto.

[source,perl6]
.Enteros
----
my $edad = 17;
say $edad.is-prime;
----

----
Verdadero
----

NOTA: Consulta http://doc.perl6.org/type/Int para una lista completa de métodos para enteros.

[source,perl6]
.Números Racionales
----
my $edad = 2.3;
say $edad.numerator;
say $edad.denominator;
say $edad.nude;
----

----
23
10
(23 10)
----

NOTA: Consulta http://doc.perl6.org/type/Rat para una lista completa de métodos para números racionales.

=== Arrays
Los Arrays son listas que contienen varios valores.

[source,perl6]
----
my @animales = ['camello','llama','búho'];
say @animales;
----

Los arrays permiten muchas operaciones, como las siguientes:

TIP: La tilde `~` se utiliza para concatenar texto.

[source,perl6]
.`Script`
----
my @animales = ['camello','vicuña','llama'];
say "El zoo tiene " ~ @animales.elems ~ " animales";
say "Los animales son: " ~ @animales;
say "He conseguido un búho para el zoo";
@animales.push("búho");
say "Los animales del zoo ahora son: " ~ @animales;
say "El primer animal del zoo es: " ~ @animales[0];
@animales.pop;
say "Desafortunadamente el búho se escapó y los animales que quedan son: " ~ @animales;
say "Hemos dejado el zoo con un animal dentro";
say "Dejamos ir a: " ~ @animales.splice(1,2) ~ " y dejamos en el zoo al " ~ @animales;
----

.`Salida`
----
El zoo tiene 3 animales
Los animales son: camello vicuña llama
He conseguido un búho para el zoo
Los animales del zoo ahora son: camello vicuña llama búho
El primer animal del zoo es: camello
Desafortunadamente el búho se escapó y los animales que quedan son: camello vicuña llama
Hemos dejado el zoo con un animal dentro
Dejamos ir a: vicuña llama y dejamos en el zoo al camello
----

.Explicación
`.elems` devuelve el número de elementos de un array. +
`.push()` añade un elemento a un array. +
Podemos acceder a un elemento concreto del array indicando su posición `@animales[0]`. +
`.pop` elimina el último elemento del array. +
`.splice(a,b)` elimina `b` elementos que comienzan en la posición `a`.

==== Arrays de tamaño fijo
Un array básico se declara así:
[source,perl6]
my @array;

El array básico puede tener un número indefinido de valores y por eso se denomina auto-extendible. +
Un array puede tener cualquier número de valores sin restricciones.

En contraste, también podemos crear arrays de tamaño fijo. +
En estos arrays se define un tamaño fijo y no puede crecer más allá de este tamaño.

Para declarar un array de tamaño fijo, especifica el número máximo de elementos entre corchetes justo después de su nombre:
[source,perl6]
my @array[3];

Este array tendrá un máximo de 3 valores, indexados desde 0 a 2.

[source,perl6]
----
my @array[3];
@array[0] = "primer valor";
@array[1] = "segundo valor";
@array[2] = "tercer valor";
----

No puedes agregar un cuarto valor a este array:
[source,perl6]
----
my @array[3];
@array[0] = "primer valor";
@array[1] = "segundo valor";
@array[2] = "tercer valor";
@array[3] = "cuarto valor";
----

----
Index 3 for dimension 1 out of range (must be 0..2)
----

==== Arrays multidimensionales
Los arrays que hemos visto hasta ahora son de una dimensión. +
Con Perl 6, podemos definir arrays de varias dimensiones.

[source,perl6]
my @tbl[3;2];

Este array es de dos dimensiones.
La primera dimensión puede tener un máximo de 3 valores y la segunda dimensión un máximo de 2 valores.

[source,perl6]
----
my @tbl[3;2];
@tbl[0;0] = 1;
@tbl[0;1] = "x";
@tbl[1;0] = 2;
@tbl[1;1] = "y";
@tbl[2;0] = 3;
@tbl[2;1] = "z";
say @tbl
----

NOTA: Consulta http://doc.perl6.org/type/Array para tener la referencia completa sobre Arrays.

=== Hashes
[source,perl6]
.Un Hash es una colección de pares Clave/Valor.
----
my %capitales = ('UK','Londres','Alemania','Berlin');
say %capitales;
----

[source,perl6]
.Otra forma de insertar valores en un hash:
----
my %capitales = (UK => 'Londres', Alemania => 'Berlin');
say %capitales;
----
Algunos de los métodos aplicables a los hashes son:
[source,perl6]
.`Script`
----
my %capitales = (UK => 'Londres', Alemania => 'Berlin');
%capitales.push: (Francia => 'Paris');
say %capitales.kv;
say %capitales.keys;
say %capitales.values;
say "La capital de Francia es: " ~ %capitales<Francia>;
----

.`Output`
----
(Alemania Berlin Francia Paris UK Londres)
(Alemania Francia UK)
(Berlin Paris Londres)
La capital de Francia es: Paris
----

.Explicación
`.push: (Clave => 'Valor')` agrega un nuevo par clave/valor. +
`.kv` devuelve una lista con todas las claves y valores. +
`.keys` devuelve una lista con todas las claves. +
`.values` devuelve una lista con todos los valores. +
Podemos acceder a un valor concreto del hash indicando su clave `%hash<clave>`

NOTA: Consulta http://doc.perl6.org/type/Hash para una referencia completa sobre hashes.

=== Tipos
En los ejemplos anteriores no hemos especificado el tipo de valor que debería contener cada variable.

TIP: `.WHAT` devuelve el tipo del valor que contiene la variable.

[source,perl6]
---------------------
my $var = 'Texto';
say $var;
say $var.WHAT;

$var = 123;
say $var;
say $var.WHAT;
---------------------

Como puedes ver en el ejemplo anterior, el tipo de valor en `$var` primero fue texto (Str) y después entero (Int).

Este estilo de programación se denomina tipado dinámico. Dinámico en el sentido de que las variables pueden contener valores de Cualquier tipo.

Ahora intenta ejecutar el siguiente ejemplo: +
Fíjate en el `Int` indicado antes de la variable.

[source,perl6]
-----------------------------------------
my Int $var = 'Texto';
say $var;
say $var.WHAT;
-----------------------------------------

Este ejemplo devuelve un error indicando: `Type check failed in assignment to $var; expected Int but got Str`

Lo que ocurre es que hemos especificado como entero (Int) el tipo de la variable y falla al intentar asignar en ella un texto (Str).

Este estilo de programación se denomina tipado estático. Estático en el sentido de que la variable se define con un tipo determinado antes de asignarla y este tipo no puede cambiarse después.

Perl 6 es un lenguaje de *tipado gradual*; lo que permite tipado *estático* y *dinámico*.

.Los arrays y hashes también pueden tener tipado estático:
[source,perl6]
----
my Int @array = 1,2,3;
say @array;
say @array.WHAT;

my Str @multilengua = "Hello","Salut","Hallo","您好","안녕하세요","こんにちは";
say @multilengua;
say @multilengua.WHAT;

my Str %capitales = (UK => 'London', Alemania => 'Berlin');
say %capitales;
say %capitales.WHAT;

my Int %código-país = (UK => 44, Alemania => 49);
say %código-país;
say %código-país.WHAT;
----

.A continuación tienes una lista con los tipos más comunes:
Es probable que no utilices nunca los dos primeros, pero los mostramos de forma informativa.

[cols="^.^1m,.^3m,.^2m,.^1m, options="header"]
|===

| *Tipo* | *Descripción* | *Ejemplo* | *Resultado*

| Mu | La raíz de la jerarquía de tipos de Perl 6 | |

| Any | Clase base por defecto para nuevas clases y para la mayoría de las clases nativas | |

| Cool | Valor que puede tratarse como texto o número indistintamente | my Cool $var = 31; say $var.flip; say $var * 2; | 13 62

| Str | Texto o cadena de carácteres | my Str $var = "NEON"; say $var.flip; | NOEN

| Int | Entero (independientemente de la precisión) | 7 + 7 | 14

| Rat | Número racional (precisión limitada) | 0.1 + 0.2 | 0.3

| Bool | Booleano | !True | False

|===

=== Introspección

Introspección es el proceso para adquirir información sobre las propiedades de un objeto, como por ejemplo su tipo. +
En uno de los ejemplos anteriores utilizamos `.WHAT` para devolver el tipo de una variable.

[source,perl6]
----
my Int $var;
say $var.WHAT;    # (Int)
my $var2;
say $var2.WHAT;   # (Any)
$var2 = 1;
say $var2.WHAT;   # (Int)
$var2 = "Hola";
say $var2.WHAT;   # (Str)
$var2 = True;
say $var2.WHAT;   # (Bool)
$var2 = Nil;
say $var2.WHAT;   # (Any)
----

El tipo de una variable que contiene un valor se corresponde con su valor. +
El tipo de una variable declarada de forma estática y sin valor es el tipo con el que se ha declarado. +
El tipo de una variable vacía que no ha sido declarada de forma estática es `(Any)` +
Asigna `Nil` a una variable para eliminar su valor.

=== Alcance
Es necesario declarar una variable antes de utilizarla.

Perl 6 dispone de varias formas de declaración, y en los siguientes ejemplos utilizaremos `my`.

[source,perl6]
my $var=1;

La forma de declaración `my` proporciona a la variable un alcance *léxico*.
Dicho de otro modo, la variable solo es accesible desde el mismo bloque donde es declarada.

En Perl 6 un bloque está delimitado por `{ }`.

En caso de no existir bloque, la variable estará disponible en el script entero.

[source,perl6]
--------------------------------
{
  my Str $var = 'Texto';
  say $var; #accesible
}
say $var; #no accesible, da un error
--------------------------------

Como la variable solo es accesible dentro del bloque donde está definida, la misma variable puede definirse de nuevo en cualquier otro bloque.

[source,perl6]
----
{
  my Str $var = 'Texto';
  say $var;
}
my Int $var = 123;
say $var;
----

=== Asignación vs. Vinculación
En los ejemplos anteriores hemos visto cómo *asignar* valores a variables. +
La *asignación* se realiza mediante el operador `=`.
[source,perl6]
----
my Int $var = 123;
say $var;
----

Y podemos cambiar el valor asignado a la variable:

[source,perl6]
.Asignación
----
my Int $var = 123;
say $var;
$var = 999;
say $var;
----

.`Salida`
----
123
999
----

Por otro lado, no podemos cambiar el valor *vinculado* de una variable. +

La *vinculación* se realiza mediante el operador `:=`.

[source,perl6]
.Vinculación
----
my Int $var := 123;
say $var;
$var = 999;
say $var;
----

.`Salida`
----
123
Cannot assign to an immutable value
----

[source,perl6]
.Las variables también pueden vincularse a otras variables:
----
my $a;
my $b;
$b := $a;
$a = 7;
say $b;
$b = 8;
say $a;
----

.`Salida`
----
7
8
----

Como has visto, la vinculación de variables es bidireccional. +
`$a := $b` y `$b := $a` tienen el mismo efecto.

NOTA: En http://doc.perl6.org/language/variables tienes más información sobre variables.

== Funciones y mutantes

Es importante diferenciar entre funciones y mutantes. +

Las funciones no cambian el estado inicial del objeto donde se aplica. +

Los mutantes modifican el estado del objeto.

[source,perl6,linenums]
.`Script`
----
my @números = [7,2,4,9,11,3];

@números.push(99);
say @números;      #1

say @números.sort; #2
say @números;      #3

@números.=sort;
say @números;      #4
----

.`Salida`
----
[7 2 4 9 11 3 99] #1
(2 3 4 7 9 11 99) #2
[7 2 4 9 11 3 99] #3
[2 3 4 7 9 11 99] #4
----

.Explicación
`.push` es un mutante porque cambia el estado del array (#1)

`.sort` es una función porque devuelve un array ordenado pero no cambia el estado inicial del array:

* (#2) muestra la devolución de un array ordenado.

* (#3) muestra que el estado inicial del array no ha cambiado.

Puedes hacer que una función se comporte como un mutante utilizando `.=` en lugar de `.` (#4) (línea 9 del script)

== Bucles y condiciones
Perl 6 tiene multitud de constructores de bucles y condiciones.

=== if
El código se ejecuta solo si se cumple la condición.

[source,perl6]
----
my $edad = 19;

if $edad > 18 {
  say 'Bienvenido'
}
----
En Perl 6 podemos invertir el código y la condición, y aún así la condición siempre se evalúa primero.

[source,perl6]
----
my $edad = 19;

say 'Bienvenido' if $edad > 18;
----

Si la condición no se cumple, podemos dar alternativas mediante bloques de ejecución utilizando:

* `else`
* `elsif`

[source,perl6]
----
#ejecuta el mismo código para distintos valores de la variable
my $número-de-asientos = 9;

if $número-de-asientos <= 5 {
  say 'Soy un sedan'
} elsif $número-de-asientos <= 7 {
  say 'Tengo 6 o 7 asientos'
} else {
  say 'Soy un microbus'
}
----

=== unless
La negación de `if` es `unless`.

El siguiente código:

[source,perl6]
----
my $limpiar-zapatos = False;

if not $limpiar-zapatos {
  say 'Limpia tus zapatos'
}
----
puede escribirse como:

[source,perl6]
----
my $limpiar-zapatos = False;

unless $limpiar-zapatos {
  say 'Limpia tus zapatos'
}
----
La negación en Perl 6 se realiza con `!` o con `not`.

`unless (condición)` se utiliza en lugar de `if not (condición)`.

`unless` no puede utilizar la claúsula `else`.

=== with

`with` es como `if` pero solo comprueba si la variable está definida.

[source,perl6]
----
my Int $var=1;

with $var {
  say 'Hola'
}
----
No ocurre nada si ejecutas el código sin asignar un valor a la variable.
[source,perl6]
----
my Int $var;

with $var {
  say 'Hola'
}
----

`without` es la negación de `with` y es parecido a `unless`.

Si la primera condición `with` no se cumple, puede indicarse una alternativa mediante `orwith`. +
`with` y `orwith` son parecidos a `if` y `elsif`.

=== for

`for` itera sobre una serie de valores.

[source,perl6]
----
my @array = [1,2,3];

for @array -> $array-item {
  say $array-item*100
}
----

Observa que en la iteración hemos creado la variable `$array-item` para realizar la operación `*100` en cada elemento del array.

=== given

En Perl 6 `given` viene a ser `switch` en otros lenguajes.

[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Menos o igual a 50'}
    when Int { say "es un Entero" }
    when 42  { say 42 }
    default  { say "¿ejem?" }
}
----

Cuando se produce la coincidencia no se evalúan las demás.

Si utilizamos `proceed` continúa la evaluación aunque se produzca la coincidencia.

[source,perl6]
----
my $var = 42;

given $var {
    when 0..50 { say 'Menos o igual a 50';proceed}
    when Int { say "es un Entero";proceed}
    when 42  { say 42 }
    default  { say "¿ejem?" }
}
----

=== loop

`loop` es otra forma de escribir un `for`.

Actualmente `loop` viene a ser el `for` utilizado en la familia de lenguajes de C.

Perl 6 pertenece a la familia de lenguajes de C.

[source,perl6]
----
loop (my $i=0; $i < 5; $i++) {
  say "El número actual es $i"
}
----

NOTA: En http://doc.perl6.org/language/control tienes más información sobre bucles y condiciones

== I/O
En Perl 6, las dos interfaces más utilizadas de _Entrada/Salida_ son el _Terminal_ y los _Ficheros_.

=== E/S básica mediante el Terminal

==== say
`say` escribe en la salida estándar agregando al final una línea nueva. En otras palabras, el siguiente código:

[source,perl6]
----
say 'Hola Mamá.';
say 'Hola Señor.';
----
escribirá dos líneas separadas.

==== print
Por otro lado `print` es como `say` pero no agrega la línea nueva.

Prueba a utilizar `say` en lugar de `print` y compara los resultados.

==== get
Para capturar la entrada desde el terminal utiliza `get`.

[source,perl6]
----
my $nombre;

say "¡Hola!, ¿cual es tu nombre?";
$nombre=get;

say "¿Que tal $nombre?, bienvenido a Perl 6";
----

Este código hace que el terminal espere la introducción de tu nombre para después darte la bienvenida.

==== prompt
`prompt` es una combinación entre `print` y `get`.

El ejemplo anterior puede escribirse de esta otra forma:

[source,perl6]
----
my $nombre = prompt("¡Hola!, ¿cual es tu nombre? ");

say "¿Que tal $nombre?, bienvenido a Perl 6";
----

=== Ejecutando Comandos del Shell
Podemos utilizar dos subrutinas para ejecutar comandos del shell:

* `run` Ejecuta un comando externo sin la intervención del shell.

* `shell` Ejecuta un comando desde el shell del sistema y tiene en cuenta todos sus caracteres especiales como tuberías, redirecciones, variables de entorno, sustitución de variables, etc.

[source,perl6]
----
my $nombre = 'Neo';
run 'echo', "Hola $nombre";
shell "ls";
----
`echo` y `ls` son dos comandos típicos del shell. +
`echo` visualiza texto en el terminal (equivale al `print` de Perl 6). +
`ls` lista todos los archivos y carpetas del directorio actual.


=== E/S de Archivos
==== slurp
`slurp` lee datos de un archivo.

Crea un archivo de texto con el siguiente contenido:

.datos.txt
----
Juan 9
Juanito 7
Juana 8
Juanita 7
----
[source,perl6]
----
my $datos = slurp "datos.txt";
say $datos;
----

==== spurt
`spurt` escribe datos en un archivo.

[source,perl6]
----
my $datos-nuevos = "Nuevas puntuaciones:
Pablo 10
Pablin 9
Paulo 11";

spurt "datos-nuevos.txt", $datos-nuevos;
----

El código anterior crea un nuevo archivo llamado _datos-nuevos.txt_ conteniendo las nuevas puntuaciones.

=== Manipulando archivos y carpetas

En un ejemplo anterior ya hemos visto que Perl 6 puede mostrar el contenido de una carpeta (mediante `ls`) sin utilizar el shell.

[source,perl6]
----
say dir;               #Muestra archivos y carpetas de la carpeta actual
say dir "/Documentos"; #Muestra archivos y carpetas de la carpeta indicada
----

Además, puedes crear carpetas nuevas y eliminarlas.

[source,perl6]
----
mkdir "carpeta-nueva";
rmdir "carpeta-nueva";
----

`mkdir` crea una carpeta nueva. +
`rmdir` elimina una carpeta vacía. Devuelve un error en caso de no existir la carpeta.

También puedes comprobar si la ruta indicada existe y si se trata de un archivo o una carpeta:

Crea una carpeta vacía llamada `carpeta123`, un archivo vacío llamado `script123.pl6` y el siguiente script:

[source,perl6]
----
say "script123.pl6".IO.e;
say "carpeta123".IO.e;

say "script123.pl6".IO.d;
say "carpeta123".IO.d;

say "script123.pl6".IO.f;
say "carpeta123".IO.f;
----

Ejecuta el script.

`IO.e` comprueba si existe la carpeta/archivo. +
`IO.f` comprueba si la ruta es un archivo. +
`IO.d` comprueba si la ruta es una carpeta.

NOTA: En http://doc.perl6.org/type/IO tienes más información sobre E/S.

== Subrutinas
=== Definición
*Subrutinas* (también denominadas *subs* o *funciones*) son una forma de empaquetar un conjunto de funcionalidades. +

La definición de una subrutina comienza con la palabra clave `sub`. Una vez definida puede invocarse mediante su nombre. +

Fíjate en el siguiente ejemplo:

[source,perl6]
----
sub saludo-alien {
  say "Hola terrícolas";
}

saludo-alien;
----
El ejemplo anterior es una subrutina sin entrada de datos.

=== Signatura
Muchas subrutinas utilizan *argumentos* de entrada para trabajar con ellos.
El número y tipo de argumentos que acepta una subrutina se denomina su *signatura*.

La siguiente subrutina acepta un argumento de tipo string.

[source,perl6]
----
sub di-hola (Str $nombre) {
    say "¡¡Hola " ~ $nombre ~ "!!"
}
di-hola "Pablo";
di-hola "Paula";
----

=== Subrutinas múltiples
Es posible definir varias subrutinas con el mismo nombre pero con distintas signaturas.
Cuando la subrutina es llamada, el entorno de ejecución decidirá qué versión de subrutina utilizar dependiendo del número y tipo de argumentos proporcionados.
Este tipo de subrutinas se definen con la palabra clave `multi` en lugar de `sub`.

[source,perl6]
----
multi saludo($nombre) {
    say "Buenos días $nombre";
}
multi saludo($nombre, $título) {
    say "Buenos días $título $nombre";
}

saludo "Juanito";
saludo "Laura","Srta.";
----

=== Argumentos por defecto y opcionales
Una subrutina fallará si se define para aceptar un argumento y éste no es proporcionado.

Con Perl 6 podemos definir subrutinas con:

* Argumentos opcionales
* Argumentos por defecto

Un argumento opcional se define agregando `?` al nombre del argumento.

[source,perl6]
----
sub di-hola($nombre?) {
  with $nombre { say "Hola " ~ $nombre }
  else { say "Hola humano" }
}
di-hola;
di-hola("Laura");
----
Si no se proporciona un argumento, puede definirse uno por defecto asignándole un valor en la definición de la subrutina.

[source,perl6]
----
sub di-hola($nombre="Mateo") {
  say "Hola " ~ $nombre;
}
say-hello;
say-hello("Laura");
----

NOTA: En http://doc.perl6.org/language/functions encontrarás más información sobre subrutinas y funciones.

== Programación Funcional
En este apartado veremos algunas funcionalidades relacionadas con la Programación Funcional.

=== Las Funciones son de primera clase
Las funciones/subrutinas son de primera clase:

* Pueden utilizarse como un argumento

* Pueden ser devueltas desde otra función

* Pueden asignarse a una variable

Un buen ejemplo para demostrar este concepto es la función `map`. +
`map` es una *función de orden superior* que acepta otra función como argumento.

[source,perl6]
.Script
----
my @array = <1 2 3 4 5>;
sub cuadrado($x) {
  $x ** 2
}
say map(&cuadrado,@array);
----

.Salida
----
(1 4 9 16 25)
----

.Explicación
Hemos definido la subrutina `cuadrado` que calcula la potencia de dos de cualquier número proporcionado como argumento. +
Después utilizamos `map`, una función de orden superior que toma dos argumentos: una subrutina y un array. +
El resultado es una lista de todos los cuadrados de los elementos del array.

Ten en cuenta que cuando pasamos una subrutina como argumento, es necesario utilizar el prefijo `&` en el nombre.

=== Clausuras
Todos los objetos de código en Perl 6 son clausuras, lo que significa que se pueden referenciar variables léxicamente definidas desde un ámbito externo.

=== Funciones anónimas
Una *función anónima* también se denomina *lambda*. +
Una función anónima no está vinculada a un identificador (no tiene nombre).

Reescribamos el ejemplo de `map` utilizando una función anónima
[source,perl6]
----
my @array = <1 2 3 4 5>;
say map(-> $x {$x ** 2},@array);
----
Observa que en lugar de declarar la función y pasarla a `map` como argumento, la definimos dentro directamente. +
La función anónima `\-> $x {$x ** 2}` no puede ser llamada.

En la jerga de Perl 6 a esta notación la llamamos *punto de entrada al bloque*

[source,perl6]
.Un punto de entrada al bloque también puede utilizarse para asignar funciones a variables:
----
my $cuadrado = -> $x {
  $x ** 2
}
say $cuadrado(9);
----

=== Encadenamiento
En Perl 6 los métodos pueden encadenarse. Esto quiere decir que no es necesario pasar el resultado de un método como argumento de otro método.

¿Cómo obtendríamos los valores únicos de un array ordenados de mayor a menor?

Puedes resolver el problema escribiendo algo así:
[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9 >;
my @final-array = reverse(sort(unique(@array)));
say @final-array;
----
Primero utilizamos la función `unique` sobre `@array`, después pasamos el resultado como argumento a `sort` y por último pasamos el resultado de la ordenación a `reverse`.

En contraste con el ejemplo anterior, Perl 6 permite la encadenación de métodos. +
El ejemplo anterior puede escribirse de la siguiente forma utilizando el *encadenamiento de métodos*:

[source,perl6]
----
my @array = <7 8 9 0 1 2 4 3 5 6 7 8 9 >;
my @final-array = @array.unique.sort.reverse;
say @final-array;
----

Como ves, el encadenamiento de métodos es _más visual_.

=== Operador de Alimentación
El *operador de alimentación*, llamado _tubería_ en algunos lenguajes de programación funcional hace aún más visual el encadenamiento de métodos.

[source,perl6]
.Alimentación hacia adelante
----
my @array = <7 8 9 0 1 2 4 3 5 6>;
@array ==> unique()
       ==> sort()
       ==> reverse()
       ==> my @final-array;
say @final-array;
----

.Explicación
----
Comienza con `@array` y devuelve una lista de elementos únicos
                    después los ordena
                    después invierte el orden
                    después guarda el resultado en @final-array
----
Como ves, el flujo de las llamadas a los métodos es de arriba hacia abajo.


[source,perl6]
.Alimentación hacia atrás
----
my @array = <7 8 9 0 1 2 4 3 5 6>;
my @final-array-v2 <== reverse()
                   <== sort()
                   <== unique()
                   <== @array;
say @final-array-v2;
----

.Explicación
La alimentación hacia atrás es parecida a la anterior pero se escribe en orden inverso. +
El flujo de las llamadas a los métodos es de abajo hacia arriba.

=== Hiperoperador
El *hiperoperador* `>>.` puede aplicar un método a todos los elementos de una lista y devolver una lista con todos los resultados.
[source,perl6]
----
my @array = <0 1 2 3 4 5 6 7 8 9 10>;
sub es-par($var) { $var %% 2 };

say @array>>.is-prime;
say @array>>.&es-par;
----
Mediante el hiperoperador podemos utilizar todos los métodos ya definidos en Perl 6, por ej. `is-prime` que devuelve si un número es primo o no. +
Además, podemos definir funciones nuevas y utilizarlas mediante el hiperoperador agregando el prefijo `&` en el nombre del método, por ej. `&es-par`.

El uso del hiperoperador es muy práctico pues evita escribir un bucle `for` para iterar sobre cada valor.

=== Uniones
Una *unión* es una superposición lógica de valores.

En el siguiente ejemplo `1|2|3` es una unión.

[source,perl6]
----
my $var = 2;
if $var == 1|2|3 {
  say "La variable es 1 o 2 o 3"
}
----
El uso de uniones normalmente produce *autothreading* para cada elemento de la unión y todos los resultados se combinan y se devuelven en una nueva unión.

=== Listas perezosas
Una *lista perezosa* es una lista que se evalúa perezosamente. +
La evaluación perezosa demora la evaluación de una expresión hasta que es requerida, guardando mientras los resultados en una tabla de búsqueda para así evitar repetir la evaluación.

Entre los beneficios tenemos:

* Incremento del rendimiento evitando cálculos innecesarios

* La habilidad de construir estructuras de datos potencialmente infinitas

* La habilidad de definir controles de flujo

Podemos definir una lista perezosa utilizando el operador infijo `...` +
Una lista perezosa tiene *elemento(s) inicial(es)*, un *generador* y un *punto final*.

[source,perl6]
.Lista perezonsa simple
----
my $listaperezosa = (1 ... 10);
say $listaperezosa;
----
El elemento inicial es 1 y el punto final es 10. Como no hemos definido un generador, por defecto es el sucesor (+1) +
Dicho de otra forma, esta lista perezosa puede devolver (si es requerida) los siguientes elementos (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

[source,perl6]
.Lista perezosa infinita
----
my $listaperezosa = (1 ... Inf);
say $listaperezosa;
----
Esta lista puede devolver (si es requerida) cualquier entero entre 1 e infinito, en otras palabras cualquier número entero.

[source,perl6]
.Lista perezosa con generador deductivo
----
my $listaperezosa = (0,2 ... 10);
say $listaperezosa;
----
Los elementos iniciales son 0 y 2, y el punto final es 10.
Aunque no hay un generador definido, Perl 6 utiliza los elementos iniciales para deducir que el generador es (+2) +
Esta lista puede devolver (si es requerida) los siguientes elementos (0, 2, 4, 6, 8, 10)

[source,perl6]
.Lista perezosa con generador definido
----
my $listaperezosa = (0, { $_ + 3 } ... 12);
say $listaperezosa;
----
En este ejemplo hemos definido de forma explícita un generador entre llaves `{ }` +
Esta lista puede devolver (si es requerida) los siguientes elementos (0, 3, 6, 9, 12)

[WARNING]
--
Al usar un generador de forma explícita el punto final debe ser uno de los valores que el generador pueda devolver. +
Si en el ejemplo anterior sustituimos el punto final 12 por un 10, el generador no parará y saltará sobre el punto final y continuará.

De forma alternativa puedes sustituir `0 ... 10` con `0 ...^ * > 10` +
Esto lo puedes leer como: De 0 hasta el primer valor mayor a 10 (excluyendo a éste)

[source,perl6]
.Esto no hace parar al generador
----
my $listaperezosa = (0, { $_ + 3 } ... 10);
say $listaperezosa;
----

[source,perl6]
.Esto hace parar al generador
----
my $listaperezosa = (0, { $_ + 3 } ...^ * > 10);
say $listaperezosa;
----
--
== Classes & Objects
In the previous chapter, we learned how Perl 6 facilitates Functional Programming. +
In this chapter we will take a look at Object Oriented programming in Perl 6.

=== Introduction

_Object Oriented_ programming is one of the widely used paradigms nowadays. +
An *object* is a set of variables and subroutines bundled together. +
The variables are called *attributes* and the subroutines are called *methods*. +
Attributes define the *state* and methods define the *behavior* of an object.

A *class* defines the structure of a set of *objects*. +

In order to understand the relationship consider the below example:

|===

| There are 4 people present in a room | *objects* => 4 people

| These 4 people are humans | *class* => Human

| They have different names, age, sex and nationality | *attributes* => name, age, sex, nationality

|===

In _object oriented_ parlance, we say that objects are *instances* of a class.

Consider the below script:
[source,perl6]
----
class Human {
  has $name;
  has $age;
  has $sex;
  has $nationality;
}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
say $john;
----
The `class` keyword is used to define a class. +
The `has` keyword is used to define attributes of a class. +
The `.new()` method is called a *constructor*. It creates the object as an instance of the class it has been called on.

In the above script, a new variable `$john` holds a reference to a new instance of "Human" defined by `Human.new()`. +
The arguments passed to the `.new()` method are used to set the attributes of the underlying object.

A class can be given _lexical scope_ using `my`:
[source,perl6]
----
my class Human {

}
----

=== Encapsulation
Encapsulation  is an object oriented concept that bundles a set of data and methods together. +
The data (attributes) within an object should be *private*, in other words, accessible only from within the object. +
In order to access the attributes from outside the object we use methods that we call *accessors*.

The below two scripts have the same result.

.Direct access to the variable:
[source,perl6]
----
my $var = 7;
say $var;
----

.Encapsulation:
[source,perl6]
----
my $var = 7;
sub sayvar {
  $var;
}
say sayvar;
----
The method `sayvar` is an accessor. It let us access the value of the variable without getting direct access to it.

Encapsulation is facilitated in Perl 6 with the use of *twigils*. +
Twigils are secondary _sigils_. They come between the sigil and the attribute name. +
Two twigils are used in classes:

* `!` is used to explicitly declare that the attribute is private.
* `.` is used to automatically generate an accessor for the attribute.

By default, all attributes are private but it is a good habit to always use the `!` twigil.

In line with what we said we should rewrite the above class as following:
[source,perl6]
----
class Human {
  has $!name;
  has $!age;
  has $!sex;
  has $!nationality;
}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
say $john;
----
Append to the script the following statement: `say $john.age;` +
It will return the following error: `Method 'age' not found for invocant of class 'Human'` +
The reason being that `$!age` is private and can only be used within the object.
Trying to access it outside the object will return an error.

Now replace `has $!age` with `has $.age` and see what will be the result of `say $john.age;`

=== Named vs. Positional Arguments
In Perl 6, all classes inherit a default `.new()` constructor. +
It can be used to create objects by providing it with arguments. +
The default constructor can only be provided with *named arguments*. +
If you consider the above example, you'll remark that all the arguments supplied to `.new()` are defined by name:

* name => 'John'

* age => 23


What if i do not want to supply the name of each attribute each time i want to create a new object? +
Then I need to create another constructor that accepts *positional arguments*.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  has $.sex;
  has $.nationality;
  #new constructor that overrides the default one.
  method new ($name,$age,$sex,$nationality) {
    self.bless(:$name,:$age,:$sex,:$nationality);
  }
}

my $john = Human.new('John',23,'M','American');
say $john;
----
The constructor that accepts positional arguments need to be defined as seen above.

=== Methods

==== Introduction
Methods are the _subroutines_ of an object. +
Like subroutines, they are a means of packaging a set of functionality, they accept *arguments*, have a *signature* and can be defined as *multi*.

Methods are defined using the `method` keyword. +
In normal circumstances, methods are required to perform some sort of action on the objects' attributes.
This enforces the concept of encapsulation. Object attributes can only be manipulated from within the object using methods.
The outside world, can only interact with the object methods, and has no access to its attributes.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  has $.sex;
  has $.nationality;
  has $.eligible;
  method assess-eligibility {
      if self.age < 21 {
        $!eligible = 'No'
      } else {
        $!eligible = 'Yes'
      }
  }

}

my $john = Human.new(name => 'John', age => 23, sex => 'M', nationality => 'American');
$john.assess-eligibility;
say $john.eligible;
----

Once methods are defined within a class, they can be called on an object using the _dot notation_: +
_object_ *.* _method_ or as in the above example: `$john.assess-eligibility`

Within the definition of a method, if we need to reference the object itself to call another method we use the `self` keyword. +

Within the definition of a method, if we need to reference an attribute we use `!` even if it was defined with `.` +
The rationale being that what the `.` twigil does is declare an attribute with `!` and automate the creation of an accessor.

In the above example `if self.age < 21` and `if $!age < 21` would have the same effect, although they are technically different:

* `self.age` calls the `.age` method (accessor) +
Can be written alternatively as `$.age`
* `$!age` is a direct call to the variable

==== Private methods
Normal methods can be called on objects from outside the class.

*Private methods* are methods that can only be called from within the class. +
A possible use case would be a method that calls another one for specific action.
The method that interfaces with the outside world is public while the one referenced should stay private.
We do not want users to call it directly, so we declare it as private.

The declaration of a private method requires the use of the `!` twigil before its name. +
Private methods are called with `!` instead of `.`

[source,perl6]
----
method !iamprivate {
  #code goes in here
}

method iampublic {
  self!iamprivate;
  #do additional things
}
----

=== Class Attributes

*Class attributes* are attributes that belong to the class itself and not to its objects. +
They can be initialized during definition. +
Class attributes are declared using `my` instead of `has`. +
They are called on the class itself instead of its objects.

[source,perl6]
----
class Human {
  has $.name;
  my $.counter = 0;
  method new($name) {
    Human.counter++;
    self.bless(:$name);
  }
}
my $a = Human.new('a');
my $b = Human.new('b');

say Human.counter;
----

=== Access Type
Until now all the examples that we've seen, used accessors to get information from the objects' attributes.

What if we need to modify the value of an attribute? +
We need to label it as _read/write_ using the following keywords `is rw`
[source,perl6]
----
class Human {
  has $.name;
  has $.age is rw;
}
my $john = Human.new(name => 'John', age => 21);
say $john.age;

$john.age = 23;
say $john.age;
----
By default, all attributes are declared as _read only_ but you can explicitly do it using `is readonly`

=== Inheritance
==== Introduction
*Inheritance* is yet another concept of object oriented programming.

When defining classes, soon enough we will realize that some attributes/methods are common to many classes. +
Should we duplicate code? +
NO! We should use *inheritance*

Let's consider we want to define two classes a class for Human beings and a class for Employees. +
Human beings have 2 attributes: name and age. +
Employees have 4 attributes: name, age, company and salary

One would be tempted to define the classes as follow:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee {
  has $.name;
  has $.age;
  has $.company;
  has $.salary;
}
----
While technically correct the above piece of code is considered conceptually poor.

A better way to write it would be as follow:
[source,perl6]
----
class Human {
  has $.name;
  has $.age;
}

class Employee is Human {
  has $.company;
  has $.salary;
}
----
The `is` keyword defines inheritance. +
In object oriented parlance we say Employee is a *child* of Human, and Human is a *parent* of Employee.

All child classes inherit the attributes and methods of the parent class, so there is no need to redefine them.

==== Overriding
Classes inherit all attributes and methods from their parent classes. +
There are cases where we need the method in the child class to behave differently than the one inherited. +
To achieve this, we redefine the method in the child class. +
This concept is called *overriding*.

In the below example, the method `introduce-yourself` is inherited by the Employee class.

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi i am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
}

my $john = Human.new(name =>'John', age => 23,);
my $jane = Employee.new(name =>'Jane', age => 25, company => 'Acme', salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----
Overriding works as follow:

[source,perl6]
----
class Human {
  has $.name;
  has $.age;
  method introduce-yourself {
    say 'Hi i am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has $.company;
  has $.salary;
  method introduce-yourself {
    say 'Hi i am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }

}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

$john.introduce-yourself;
$jane.introduce-yourself;
----

Depending of which class the object is, the right method will be called.

==== Submethods
*Submethods* are a type of method that are not inherited by child classes. +
They are only accessible from the class they were declared in. +
They are defined using the `submethod` keyword.

=== Multiple Inheritance
Multiple inheritance is allowed in Perl 6. A class can inherit from multiple other classes.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
----

.Explanation
The `combo-chart` class should be a able to hold two series, one for the actual values plotted on bars,
and another for forecast values plotted on a line. +
This is why we defined it as a child of `line-chart` and `bar-chart`. +
You should have noticed that calling the method `plot` on the `combo-chart` didn't yield the required result.
Only one series was plotted. +
Why did this happen? +
`combo-chart` inherits from `line-chart` and `bar-chart`, and both of them have a method called `plot`.
When we call that method on `combo-chart` Perl 6 internals will try to resolve the conflict by calling one of the inherited methods.

.Correction
In order to behave correctly, we should have overridden the method `plot` in the `combo-chart`.

[source,perl6]
----
class bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

class line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart is bar-chart is line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
Actual sales:
[10 9 11 8 7 10]
Forecast sales:
[9 8 10 7 6 9]
Actual vs Forecast:
[10 9 11 8 7 10]
[9 8 10 7 6 9]
----

=== Roles
*Roles* are somehow similar to classes in the sense that they are a collection of attributes and methods.

Roles are declared with the keyword `role` and classes that wish to implement the role can do so using the `does` keyword.

.Lets rewrite the multiple inheritance example using roles:
[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
  method plot {
    say @.bar-values;
    say @.line-values;
  }
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

Run the above script and you will see that results are the same.

By now you're asking yourself; if roles behave like classes what's their use? +
To answer your question modify the first script used to showcase multiple inheritance,
the one where we _forgot_ to override the `plot` method.

[source,perl6]
----
role bar-chart {
  has Int @.bar-values;
  method plot {
    say @.bar-values;
  }
}

role line-chart {
  has Int @.line-values;
  method plot {
    say @.line-values;
  }
}

class combo-chart does bar-chart does line-chart {
}

my $actual-sales = bar-chart.new(bar-values => [10,9,11,8,7,10]);
my $forecast-sales = line-chart.new(line-values => [9,8,10,7,6,9]);

my $actual-vs-forecast = combo-chart.new(bar-values => [10,9,11,8,7,10],
                                         line-values => [9,8,10,7,6,9]);
say "Actual sales:";
$actual-sales.plot;
say "Forecast sales:";
$forecast-sales.plot;
say "Actual vs Forecast:";
$actual-vs-forecast.plot;
----

.`Output`
----
===SORRY!===
Method 'plot' must be resolved by class combo-chart because it exists in multiple roles (line-chart, bar-chart)
----

.Explanation
If multiple roles are applied to the same class, and a conflict arises, a compile-time error will be thrown. +
This is a much safer approach than multiple inheritance where conflicts are not considered errors and are simply resolved at runtime.

Roles will warn you that there's a conflict.

=== Introspection
*Introspection* is the process of getting information about an object properties like its type, or its attributes or its methods.

[source,perl6]
----
class Human {
  has Str $.name;
  has Int $.age;
  method introduce-yourself {
    say 'Hi i am a human being, my name is ' ~ self.name;
  }
}

class Employee is Human {
  has Str $.company;
  has Int $.salary;
  method introduce-yourself {
    say 'Hi i am a employee, my name is ' ~ self.name ~ ' and I work at: ' ~ self.company;
  }
}

my $john = Human.new(name =>'John',age => 23,);
my $jane = Employee.new(name =>'Jane',age => 25,company => 'Acme',salary => 4000);

say $john.WHAT;
say $jane.WHAT;
say $john.^attributes;
say $jane.^attributes;
say $john.^methods;
say $jane.^methods;
say $jane.^parents;
if $jane ~~ Human {say 'Jane is a Human'};
----
Introspection is facilitated by:

* `.WHAT` returns the class from which the object has been created.

* `.^attributes` returns a list containing all attributes of the objects.

* `.^methods` returns all methods that can be called on the object.

* `.^parents` returns all parent classes of the class the object belongs.

* `~~` is called the smart-match operator.
It evaluates to _True_ if the object is created from the class it is being compared against or any of its inheritances.

== Exception Handling

=== Catching Exceptions
*Exceptions* are a special behavior that happens at runtime when something goes wrong. +
We say that exceptions are _thrown_.

Consider the below script that runs correctly:

[source,perl6]
----
my Str $name;
$name = "Joanna";
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Hello Joanna
How are you doing today?
----

Now consider this script that throws an exception:

[source,perl6]
----
my Str $name;
$name = 123;
say "Hello " ~ $name;
say "How are you doing today?"
----

.`Output`
----
Type check failed in assignment to $name; expected Str but got Int
   in block <unit> at exceptions.pl6:2
----

You should have remarked that whenever an error occurs (in this case assigning a number to a string variable) the program will stop and other lines of code will not be evaluated, even if correct.

*Exception handling* is the process of _catching_ an exception that has been _thrown_ in order for the script to continue working.

[source,perl6]
----
my Str $name;
try {
  $name = 123;
  say "Hello " ~ $name;
  CATCH {
    default {
      say "Can you tell us your name again, we couldn't find it in the register.";
    }
  }
}
say "How are you doing today?";
----

.`Output`
----
Can you tell us your name again, we couldn't find it in the register.
How are you doing today?
----

Exception handling is done by using a `try-catch` block.

[source,perl6]
----
try {
  #code goes in here
  #if anything goes wrong, the script will enter the below CATCH block
  #if nothing goes wrong the CATCH block will be ignored
  CATCH {
    default {
      #the code in here will be evaluated only if an exception has been thrown
    }
  }
}
----

The `CATCH` block can be defined the same way a `given` block is defined.
This means we can _catch_ and handle differently many types of exceptions.

[source,perl6]
----
try {
  #code goes in here
  #if anything goes wrong, the script will enter the below CATCH block
  #if nothing goes wrong the CATCH block will be ignored
  CATCH {
    when X::AdHoc { #do something if an exception of type X::AdHoc is thrown }
    when X::IO { #do something if an exception of type X::IO is thrown }
    when X::OS { #do something if an exception of type X::OS is thrown }
    default { #do something if an exception is thrown and doesn't belong to the above types }
  }
}
----

=== Throwing Exceptions
In contrast to catching exceptions, Perl 6 also allows you to explicitly throw exceptions. +
Two types of exceptions can be thrown:

* ad-hoc exceptions

* typed exceptions

[source,perl6]
.ad-hoc
----
my Int $age = 21;
die "Error !";
----

[source,perl6]
.typed
----
my Int $age = 21;
X::AdHoc.new(payload => 'Error !').throw;
----

Ad-hoc exceptions are thrown using the `die` subroutine followed by the exception message.

Typed exceptions are objects, hence the use of the `.new()` constructor in the above example. +
All typed exceptions descend from class `X` , below are a few examples: +
`X::AdHoc` is the simplest exception type +
`X::IO` is related to IO errors +
`X::OS` is related to OS errors +
`X::Str::Numeric` related to trying to coerce a string to a number

NOTE: For a complete list of exception types and their associated methods go to http://doc.perl6.org/type.html and navigate to types starting with X.


== Regular Expressions
A regular expression, or _regex_ is a sequence of characters that is used for pattern matching. +
The easiest way to understand it is to think of it as a pattern.

[source,perl6]
----
if 'enlightenment' ~~ m/ light / {
    say "enlightenment contains the word light";
}
----

In this example, the smart match operator `~~` is used to check if a string (enlightenment) contains the word (light). +
"Enlightenment" is matched against a regex `m/ light /`

=== Regex definition

A regular expression can be defined as follows:

* `/light/`

* `m/light/`

* `rx/light/`

Unless specified explicitly, white space is irrelevant, `m/light/` and `m/ light /` are the same.

=== Matching characters
Alphanumeric characters and the underscore `_` are written as is. +
All other characters have to be escaped using a backslash or surrounded by quotes.

[source,perl6]
.Backslash
----
if 'Temperature: 13' ~~ m/ \: / {
    say "The string provided contains a colon :";
}
----

[source,perl6]
.Single quotes
----
if 'Age = 13' ~~ m/ '=' / {
    say "The string provided contains an equal character = ";
}
----

[source,perl6]
.Double quotes
----
if 'name@company.com' ~~ m/ "@" / {
    say "This is a valid email address because it contains an @ character";
}
----

=== Matching categories of characters
Characters can be classified into categories and we can match against them. +
We can also match against the inverse of that category (everything except it):

|===

| *Category* | *Regex* | *Inverse* | *Regex*

| Word character (letter, digit or underscore) | \w | Any character except a word character | \W

| Digit | \d | Any character except a digit | \D

| Whitespace | \s | Any character except a whitespace | \S

| Horizontal whitespace | \h | Any character except a horizontal whitespace | \H

| Vertical whitespace | \v | Any character except a vertical whitespace | \V

| Tab | \t | Any character except a Tab | \T

| New line | \n | Any character except a new line | \N

|===

[source,perl6]
----
if "John123" ~~ / \d / {
  say "This is not a valid name, numbers are not allowed";
} else {
  say "This is a valid name"
}
if "John-Doe" ~~ / \s / {
  say "This string contains whitespace";
} else {
  say "This string doesn't contain whitespace"
}
----

=== Unicode properties
Matching against categories of characters as seen in the preceding section is convenient. +
That being said, a more systematic approach would be to use of Unicode properties. +
Unicode properties are enclosed in `<: >`

[source,perl6]
----
if "John123" ~~ / <:N> / {
  say "Contains a number";
} else {
  say "Doesn't contain a number"
}
if "John-Doe" ~~ / <:Lu> / {
  say "Contains an uppercase letter";
} else {
  say "Doesn't contain an upper case letter"
}
if "John-Doe" ~~ / <:Pd> / {
  say "Contains a dash";
} else {
  say "Doesn't contain a dash"
}
----

=== Wildcards
Wildcards can also be used in a regex.

The dot `.` means any single character.

[source,perl6]
----
if 'abc' ~~ m/ a.c / {
    say "Match";
}
if 'a2c' ~~ m/ a.c / {
    say "Match";
}
if 'ac' ~~ m/ a.c / {
    say "Match";
  } else {
    say "No Match";
}
----

=== Quantifiers
Quantifiers come after a character and are used to specify how many times we are expecting it.

The question mark `?` means zero or one time.

[source,perl6]
----
if 'ac' ~~ m/ a?c / {
    say "Match";
  } else {
    say "No Match";
}
if 'c' ~~ m/ a?c / {
    say "Match";
  } else {
    say "No Match";
}
----

The star `*` means zero or multiple times.

[source,perl6]
----
if 'az' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaz' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
if 'z' ~~ m/ a*z / {
    say "Match";
  } else {
    say "No Match";
}
----

The `+` means at least one time.

[source,perl6]
----
if 'az' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaz' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
if 'aaaaaaaaaaz' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
if 'z' ~~ m/ a+z / {
    say "Match";
  } else {
    say "No Match";
}
----

=== Match Results
Whenever the process of matching a string against a regex is successful,
the match result is stored in a special variable `$/`

[source,perl6]
.Script
----
if 'Rakudo is a Perl 6 compiler' ~~ m/:s Perl 6/ {
    say "The match is: " ~ $/;
    say "The string before the match is: " ~ $/.prematch;
    say "The string after the match is: " ~ $/.postmatch;
    say "The matching string starts at position: " ~ $/.from;
    say "The matching string ends at position: " ~ $/.to;
}
----

.Output
----
The match is: Perl 6
The string before the match is: Rakudo is a
The string after the match is:  compiler
The matching string starts at position: 12
The matching string ends at position: 18
----

.Explanation
`$/` returns a _Match Object_ (the string that matches the regex) +
The following methods can be called on the _Match Object_: +
`.prematch` returns the string preceding the match. +
`.postmatch` returns the string following the match. +
`.from` returns the starting position of the match. +
`.to` returns the ending position of the match. +

TIP: By default whitespace in a regex definition is irrelevant. +
If we want to match against a regex containing whitespace we have to do so explicitly. +
The `:s` in the regex `m/:s Perl 6/` forces whitespace to be considered and not discarded. +
Alternatively we could have written the regex as `m/ Perl\s6 /` and used `\s` which as we saw earlier is a placeholder for whitespace. +
If a regex contains more than a single whitespace, using `:s` becomes more effective in contrast with using `\s` for each and every whitespace.

=== Example
Lets check if an email is valid or not. +
For the sake of this example we will assume that a valid email address is formed as following: +
first name [dot] last name [at] company [dot] (com/org/net)

WARNING: The regex used in this example for email validation is not very accurate. +
Its sole purpose is to demonstrate regex functionality in Perl 6. +
Do not use it as-is in production.

[source,perl6]
.Script
----
my $email = 'john.doe@perl6.org';
my $regex = / <:L>+\.<:L>+\@<:L+:N>+\.<:L>+ /;

if $email ~~ $regex {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

.Output
`john.doe@perl6.org is a valid email`

.Explanation
`<:L>` matches a single letter +
`<:L>+` matches a single letter or more +
`\.` matches a single [dot] character +
`\@` matches a single [at] character +
`<:L+:N>` matches a letter and a number +
`<:L+:N>+` matches one or more (letters and numbers) +

The regex can be decomposed as following:

* *first name* `<:L>+`

* *[dot]* `\.`

* *last name* `<:L>+`

* *[at]* `\@`

* *company name* `<:L+:N>+`

* *[dot]* `\.`

* *com/org/net* `<:L>+`

[source,perl6]
.Alternatively a regex can be broken down into multiple named regexes
----
my $email = 'john.doe@perl6.org';
my regex many-letters { <:L>+ };
my regex dot { \. };
my regex at { \@ };
my regex many-letters-numbers { <:L+:N>+ };

if $email ~~ / <many-letters> <dot> <many-letters> <at> <many-letters-numbers> <dot> <many-letters> / {
  say $/ ~ " is a valid email";
} else {
  say "This is not a valid email";
}
----

A named regex is defined using the following syntax: `my regex regex-name { regex definition }` +
A named regex can be called using the following syntax: `<regex-name>`

NOTE: For more info on regexes, see http://doc.perl6.org/language/regexes

== Perl 6 Modules
Perl 6 is a general purpose programming language. It can be used to tackle a multitude of tasks including:
text manipulation, graphics, web, databases, network protocols etc.

Reusability is a very important concept whereby programmers don't have to reinvent the wheel each time they want to do a new task.

Perl 6 allows the creation and redistribution of *modules*. Each module is a packaged set of functionality that can be reused once installed.

_Panda_ is a module management tool that comes with Rakudo.

To install a specific module, type the below command in your terminal:

`panda install "module name"`

NOTE: The Perl 6 modules directory can be found on: http://modules.perl6.org/

=== Using Modules
MD5 is a cryptographic hash function that produces a 128-bit hash value. +
MD5 has a variety of applications of which encryption of passwords stored in a database.
When a new user registers, their credentials are not stored as plain text but rather _hashed_.
The rationale behind this is that if the DB gets compromised, the attacker will not be able to know what the passwords are.

Lets say you need a script that generates the MD5 hash of a password in preparation for storing it in the DB.

Luckily there's a Perl 6 module that already implemented the MD5 algorithm. Lets install it: +
`panda install Digest::MD5`

Now run the below script:
[source,perl6]
----
use Digest::MD5;
my $password = "password123";
my $hashed-password = Digest::MD5.new.md5_hex($password);

say $hashed-password;
----
In order to run the `md5_hex()` function that creates hashes, we need to load the required module. +
The `use` keyword loads the module for use in the script.

WARNING: In practice MD5 hashing alone is not sufficient, because it is prone to dictionary attacks. +
It should be combined with a salt link:https://en.wikipedia.org/wiki/Salt_(cryptography)[https://en.wikipedia.org/wiki/Salt_(cryptography)].

== Unicode

Unicode is a standard for encoding and representing text, that caters for most writing systems in the world. +
UTF-8 is a character encoding capable of encoding all possible characters, or code points, in Unicode.

Characters are defined by a: +
*Grapheme*: Visual representation. +
*Code point*: A number assigned to the character.

=== Using Unicode

.Lets look at how we can output characters using Unicode
[source,perl6]
----
say "a";
say "\x0061";
say "\c[LATIN SMALL LETTER A]";
----
The above 3 lines showcase different ways of building a character:

. Writing the character directly (grapheme)

. Using `\x` and the code point

. Using `\c` and the code point name

.Now lets output a smiley
[source,perl6]
----
say "☺";
say "\x263a";
say "\c[WHITE SMILING FACE]";
----

.Another example combining two code points
[source,perl6]
----
say "á";
say "\x00e1";
say "\x0061\x0301";
say "\c[LATIN SMALL LETTER A WITH ACUTE]";
----

The letter `á` can be written:

* using its unique code point `\x00e1`

* or as a combination of the code points of `a` and acute `\x0061\x0301`

.Some of the methods that can be used:
[source,perl6]
----
say "á".NFC;
say "á".NFD;
say "á".uniname;
----

.`Output`
----
NFC:0x<00e1>
NFD:0x<0061 0301>
LATIN SMALL LETTER A WITH ACUTE
----

`NFC` returns the unique code point. +
`NFD` decomposes the character and return the code point of each part. +
`uniname` returns the code point name.

.Unicode letters can be used as identifiers:
[source,perl6]
----
my $Δ = 1;
$Δ++;
say $Δ;
----

== Parallelism, Concurrency and Asynchrony

=== Parallelism
Under normal circumstances, all tasks in a program run sequentially. +
This might not be a problem unless what you're trying to do is consuming a lot of time.

Naturally speaking Perl 6 has features that will enable you to run things in parallel. +
At this stage, it is important to note that parallelism can mean one of two things:

* *Task Parallelism*: Two (or more) independent expressions running in parallel.

* *Data Parallelism*: A single expression iterating over a list of elements in parallel.

Lets begin with the latter.

==== Data Parallelism
[source,perl6]
----
my @array = (0..50000);                     #Array population
my @result = @array.map({ is-prime $_ });   #call is-prime for each array element
say now - INIT now;                         #Output the time it took for the script to complete
----

.Considering the above example:
We are only doing one operation `@array.map({ is-prime $_ })` +
The `is-prime` subroutine is being called for each array element sequentially: +
`is-prime @array[0]` then `is-prime @array[1]` then `is-prime @array[2]` etc.

.Fortunately we can call `is-prime` on multiple array elements at the same time:
[source,perl6]
----
my @array = (0..50000);                         #Array population
my @result = @array.race.map({ is-prime $_ });  #call is-prime for each array element
say now - INIT now;                             #Output the time it took to complete
----

Notice the use of `race` in the expression.
This method will enable parallel iteration of the array elements.

After running both examples (with and without `race`), compare the time it took for both scripts to complete.

[TIP]
--
`race` will not preserve the order of elements. If you wish to do, so use `hyper` instead.

[source,perl6]
.race
----
my @array = (1..1000);
my @result = @array.race.map( {$_ + 1} );
@result>>.say;
----

[source,perl6]
.hyper
----
my @array = (1..1000);
my @result = @array.hyper.map( {$_ + 1} );
@result>>.say;
----

If you run both examples, you should notice that one is sorted and the other is not.

--

==== Task Parallelism

[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my @result1 = @array1.map( {is-prime($_ + 1)} );
my @result2 = @array2.map( {is-prime($_ - 1)} );

say @result1 == @result2;

say now - INIT now;
----

.Considering the above example:

. We defined 2 arrays

. applied a different operation for each array and stored the results

. and checked if both results are the same

The script waits for `@array1.map( {is-prime($_ + 1)} )` to finish +
and then evaluates `@array2.map( {is-prime($_ - 1)} )`

Both operations applied to each array do not depend on each other.

.Why not do both in parallel?
[source,perl6]
----
my @array1 = (0..49999);
my @array2 = (2..50001);

my $promise1 = start @array1.map( {$_ + 1} );
my $promise2 = start @array2.map( {$_ - 1} );

my @result1 = await $promise1;
my @result2 = await $promise2;

say @result1 == @result2;

say now - INIT now;
----

.Explanation
The `start` method evaluates the code and returns *an object of type promise* or shortly *a promise*. +
If the code is evaluated correctly, the _promise_ will be *kept*. +
If the code throws an exception, the _promise_ will be *broken*.

The `await` method waits for a *promise*. +
If it's *kept* it will get the returned values. +
If it's *broken* it will get the exception thrown.

Check the time it took each script to complete.

WARNING: Parallelism always adds a threading overhead. If that overhead is not offset by gains in computational speed, the script will seem slower. +
This is why, using `race`, `hyper`, `start` and `await` for fairly simple scripts can actually slow them down.

=== Concurrency and Asynchrony
NOTE: For more info on Concurrency and Asynchronous Programming, see http://doc.perl6.org/language/concurrency

== The community

Much discussion happens on the link:irc://irc.freenode.net/#perl6[#perl6] IRC channel. This should be your go to place for any enquiry: +
http://perl6.org/community/irc

Stay tuned by reading blog posts that focus on Perl 6: +
http://pl6anet.org/ is a Perl 6 blog aggregator.
